<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./assets/style.css">
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  </head>
  <body>
    <textarea id="source">

class: center, middle

# The Pragmatic Architecture

---
class: center, 

---
# The goal of software architecture

- Easy to understand
- Easy to test
- Easy to change
- Easy to maintain

---
# What happens with no architecture?

<div style="text-align: center;">
  <img src="./assets/no-arch.png" alt="Example Image" style="width:350px;">
</div>

---
# What happens with no architecture?

<div style="text-align: center;">
  <img src="./assets/spaghetti.jpg" alt="Example Image" style="width:500px;">
</div>

---
# What happens with no architecture?

<div style="text-align: center;">
  <img src="./assets/no-arch-structure.png" alt="Example Image" style="width:400px;">
</div>
---

# No architecture

‚úÖPros:
- Little to no abstraction
- Quick prototypes

‚ùåCons:
- Difficult to test
- Difficult to maintain
- Difficult for bigger teams
- Technology change impacts the whole system
---
# Traditional N-tier Layered Architecture


<div style="text-align: center;">
  <img src="./assets/n-tier.png" alt="Example Image" style="width:350px;">
</div>
---
# Traditional N-tier Layered Architecture


<div style="text-align: center;">
  <img src="./assets/n-tier-arch.png" alt="Example Image" style="width:400px;">
</div>

---
# DDD N-tier Layered Architecture

<div style="text-align: center;">
  <img src="./assets/ddd-n-tier.png" alt="Example Image" style="width:350px;">
</div>


---
#  N-tier Layered Architecture

‚úÖPros:
- Better Separation of Concerns
- Improved testability

‚ùåCons:
- Increased development time
- Difficult to maintain over time
- Not ideal for multiple teams

---
#  Clean Architectures

Onion Architecture

<div style="text-align: center;">
  <img src="./assets/clean-arch1.png" alt="Example Image" style="width:350px;">
</div>

---
#  Clean Architectures

Clean Architecture by Uncle Bob

<div style="text-align: center;">
  <img src="./assets/clean-arch2.jpg" alt="Example Image" style="width:450px;">
</div>

---
#  Clean Architectures

Hexagonal Architecture

<div style="text-align: center;">
  <img src="./assets/clean-arch3.png" alt="Example Image" style="width:450px;">
</div>
---

# Clean Architectures

‚úÖPros:
- Independent of frameworks
- Independent of UI, DB and any external dependencies
- Testable

‚ùåCons:
- Too opinionated - too many rules
- Organized by technical concerns
- Changes involves many layers - slower development time
- High entry curve for new developers

???
- high entry curve for developers
    - to understand functionality, you need to have many files open and jump back and forth
---
# ‚ùå Too many rules

Tells you how to write software without knowing the domain.

<div style="text-align: center;">
  <img src="./assets/best-practice-worst.png" alt="Example Image" style="width:450px;">
</div>
---
# ‚ùå Organized by technical concerns

<div style="text-align: center;">
  <img src="./assets/tech-layers-1.png" alt="Example Image" style="width:780px;">
</div>

---
# ‚ùå Organized by technical concerns

<div style="text-align: center;">
  <img src="./assets/tech-layers-2.png" alt="Example Image" style="width:780px;">
</div>

---
# ‚ùå Organized by technical concerns

<div style="text-align: center;">
  <img src="./assets/tech-layers-3.png" alt="Example Image" style="width:780px;">
</div>


---
# ‚ùå Organized by technical concerns

<div style="text-align: center;">
  <img src="./assets/tech-layers-4.png" alt="Example Image" style="width:780px;">
</div>


---
# ‚ùå Organized by technical concerns

<div style="text-align: center;">
  <img src="./assets/tech-layers-5.png" alt="Example Image" style="width:780px;">
</div>


---
# ‚ùå Organized by technical concerns

<div style="text-align: center;">
  <img src="./assets/tech-layers-6.png" alt="Example Image" style="width:780px;">
</div>

---
# ‚ùå Organized by technical concerns

<div style="text-align: center;">
  <img src="./assets/tech-layers-7.png" alt="Example Image" style="width:780px;">
</div>

---
# Low coupling, high cohesion

Coupling: degree of interdependency between software modules

Cohesion: degree to which the elemnets inside a module belong together

---
class: center, middle

# Does Clean Architecture solve this?

---
# ‚ùå Low coupling?

Spider web of calls
<div style="text-align: center;">
  <img src="./assets/clean-arch-cross-call.png" alt="Example Image" style="width:580px;">
</div>

---
#‚ùå High cohesion?

Many areas of change

Feature componetns are scattered

Too many tabs open

---
class: middle, center

# Is there a better way???

---
class: middle, center

# <span class="green-bg">Vertical Slice Architecture</span>

---

# Layers of Clean Architecture
<div style="text-align: center;">
  <img src="./assets/vsa-ca-layered.png" alt="Example Image" style="width:700px;">
</div>

---
# Remove technical layers
<div style="text-align: center;">
  <img src="./assets/vsa-unlayered.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-1.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-2.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-3.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-4.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-5.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-6.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-7.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-8.png" alt="Example Image" style="width:700px;">
</div>

---


# Use only what you need
<div style="text-align: center;">
  <img src="./assets/vsa-mixed.png" alt="Example Image" style="width:700px;">
</div>

???
It gives us the freedom to use what we want

Architecture does not tell us what to do.

Domain drives the design.
---
# Logical boundaries

Segregated by logical boundaries

Sharing still happens!

<div style="text-align: center;">
  <img src="./assets/vsa-shared-model.png" alt="Example Image" style="width:700px;">
</div>

---

# Web App characteriscs

<div style="text-align: center;">
  <img src="./assets/vsa-web-app-char.png" alt="Example Image" style="width:600px;">
</div>

---

# CQRS

Command and Query Segregation Principle

Two models: read and write

Separation of Concerns


<div style="text-align: center;">
  <img src="./assets/vsa-cqrs.png" alt="Example Image" style="width:400px;">
</div>

---

# VSA + CQRS

Commands and Queries are first class citizens

Only way to communicate with the apps

Simple Model For Requests

<div style="text-align: center;">
  <img src="./assets/vsa-request-model.png" alt="Example Image" style="width:600px;">
</div>

---

# VSA + CQRS

<div style="text-align: center;">
  <img src="./assets/vsa-cqrs-together.png" alt="Example Image" style="width:600px;">
</div>

---
class: middle, center

# <span class="green-bg">How to do VSA in .NET?</span>
---
# Modelling requests in .NET

Mediator pattern

MediatR library

<div style="text-align: center;">
  <img src="./assets/mediatr.png" alt="Example Image" style="width:300px;">
</div>

???

The mediator pattern is like a "middle friend" that helps different parts talk to each other without needing to know everyone else.
In MediatR, this "middle friend" handles messages (or requests) between parts of your app, so they can talk without directly knowing each other.

---
# Modelling requests in .NET

<div style="text-align: center;">
  <img src="./assets/vsa-request-model-net1.png" alt="Example Image" style="width:600px;">
</div>

---

# Modelling requests in .NET

<div style="text-align: center;">
  <img src="./assets/vsa-request-model-net2.png" alt="Example Image" style="width:600px;">
</div>

<div style="text-align: center;">
  <pre>
<code>
Task Handle(Query request){...}

Task Handle(Command request){...}
</code>
</pre>

</div>
---
# Modelling requests in .NET

```
public class GetAllProductsQuery : IRequest<Result<Response>>
{
}
```

```
public class GetProductQuery : IRequest<Result<Response>>
{
    public Guid Id { get; set; }
}
```

```
public class SearchForProductsQuery : IRequest<Result<Response>>
{
    public String Name { get; set; }
    public decimal Price { get; set; }
    public bool IsOnDiscount { get; set; }
}
```

---

# Modelling requests in .NET

```
public class ActivateDiscountsCommand : IRequest<Result<Guid>>
{
}
```

```
public class CreateProductCommand : IRequest<Result<Guid>>
  {
      public string Name { get; set; }

      public string Description { get; set; }

      public decimal Price { get; set; }
  }
```

---
# Modelling responses in .NET

<span class="red-bg">Don't use exceptions for control flow.</span>

<span class="green-bg">Exceptions are only for exceptional situations.</span>

2 kinds of errors:
- you know how to handle
  - use result paradigm
- you don't know how to handle
  - use exceptions
  - catch and handle at the lowerst level
#
---
# Result paradigm

```
public class Result<T>
  {
      private Result(bool isSuccess, T value, Error error)
      {
          ...
      }
  
      public bool IsSuccess { get; }
  
      public bool IsFailure => !IsSuccess;
  
      public T Value { get; }
  
      public Error Error { get; }
  
      public static Result<T> Success(T value) 
        => new(true, value, Error.None);
  
      public static Result<T> Failure(Error error) 
        => new(false, default, error);
  }
```
---
# Modelling responses in .NET

```
public class GetProductQuery : IRequest<Result<Response>>
{
    public Guid Id { get; set; }
}

public class Response
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public decimal Price { get; set; }
}
```
---
# How to organize code

Move code to a single physical place

<div style="text-align: center;">
  <img src="./assets/vsa-move-services.png" alt="Example Image" style="width:700px;">
</div>
---
# How to organize code

üìÅ Features

    |__ üìÅCarPicker
       |__ üóé ReserveCar.cs
       |__ üóé UnreserveCar.cs
       |__ üóé HoldCar.cs
       |__ üóé ...
    |__ üìÅUserManager

    |__ üìÅPaymentProcessor

    |__ üìÅInvoiceGenerator

    |__ üìÅSupportCenter

    |__ ...

---

# How to organize one feature

One class - One file - one folder

<div style="text-align: center;">
  <img src="./assets/vsa-net-collapsed.png" alt="Example Image" style="width:500px;">
</div>

---
class: center, middle

# <span class="orange-bg">Why all of this so powerfull?</span>

---
# Pragmatism

- ‚úÖ Minimal and lean solution
- ‚úÖ Guidelines over rigid rules
- ‚úÖ Freedom of choice

<div style="text-align: center;">
  <img src="./assets/vsa-query-3-forms.png" alt="Example Image" style="width:600px;">
</div>

???
It supports to mindset of a pragmatic engineer menaing ...
That is how we want to keep our solutions lean, simple and minimal. 
Software practices are guidelines not rigid rules.

it does not mean that my team members can do whatever they want.
but they can use whatever they need

the best practice is is to use our critical thinking

---

# High cohesion

‚úÖ Everything in one place

‚úÖ Screaming architecture

‚úÖ App is organized by features, not by technical concerns

‚úÖ Focused on business logic

---

# How about coupling?

‚úÖ High coupling inside the slice

‚úÖ Low coupling with other features

‚úÖ Reduced complexity -> more confidence


???
high coupling inside slcie is readonable as the things which sh ould change together should live together
---
class: center, middle

# <span class="red-bg"> That's it? </span>

---
class: center, middle

# <span class="green-bg">The Ultimate TDD Strategy </span>

---

# Two kind of unit tests

<div style="text-align: center;">
  <img src="./assets/vsa-solitary-vs-sociable.png" alt="Example Image" style="width:600px;">
</div>


---
class: center, middle

# <span class="red-bg">Don't couple your tests to code structure</span>

# <span class="green-bg">Couple them to the behaviours of the public APIs</span>

???
dont; coumple your tests to code strucrture, they will be fragile, bla bla
---
# Sociable test on WebAPI

- Feature represents the API
- London mixed with Chicago
- State vs interaction verification
- No low-level tests

<div style="text-align: center;">
  <img src="./assets/vsa-sociable-web-api.png" alt="Example Image" style="width:500px;">
</div>

???
  - Exceptions: domain heavy logic or prop tests

---
TODO: Add image of mixing the inside wih different ways of handling stuff, also add layered or clean archi in the end
---
- SOLITARY VS SOCIABLE TEST
- LONDON
- CGHICAGO FOR state
    - IBERACTIS FOR EXTERNA L SERVUICE CALLS
- NO LOW level
-    EXCEPTIONS: domain entities, business heavy logic, property based testing
-REFACTOR ARCHITECTURE EASILY - NO FRAGILE  TESTS
---
Notes:

Layered Archi, Hexagonal Architecture, values
You can have use TDD on all, the problem with the first 2 that they are too opinionated 


Pragmatic Archiecture is a methdlogy/mindset, not an endstate

How much design do we need to implement right now to keep the codebase maintainable?

That is how we want to keep our solutions lean, simple and minimal. 

This is how we can shift away from thinking about endstates and required structures.

Get what is good, trhrow away what is right.

How about DDD? 

Get what is good: uniquitios language, model distillation, bounded context

add jimmys's image

Throw away what you dont need: Patterns are good, but not like 

Add post image: guidelines, not rigid rules

DDD is not about sturctural patterns, it is about collaborating closely with domain experts and have a clear understand about what we want to build, then do it in short, Iterative
Dont ask the csutoemr what features they want.

https://verticalslicearchitecture.com/

Disadvantages:

Talk about why Repository pattern is an anti paytern violating SRP

---jim
VSA:
move code to single place

InvoiceSerivce
- void approved
- void Reject
- void flag
todO: show image to move these into separate classes

Move these to separate, they are phusicall separated

Commans/Queries first class citizens

Modelling requests:
Input -> RequestHandler -> Output (chcek jim immage)

MediatR
IRequest -> IRequestHandle<TReq,TRes> -> TResponse

Image about coming a GET/Request, goes to WebApp layer then to query-handle-response or command-handler-response

Image about Complete Encapsulation

Areas of change only one folder, that's it

QUERIES:
Query->Response->Handler
Show code about Queriy types

SHow code about Response

Show example code of Handler, where we use ORM
Show example where we use raw SQL, so we optimize

Query -> ORM - Response
Query -> dapperrawSql -> Response
Query -> HttpClient - Response

You dont need, But you ahve the easy freedom.

But shared logic in common:
- class, function, extension method (check other part for this)


COMMANDS:

Show example of Command:
(like user type input)

Command is a model of an indivudual operation

Show an UI image with thre button then on the right show the 3 C-H-Resp image

modellingReponse: 
- success of fail
- guid
- or even complex result - check Jim code about complex response (introduce only if needed)


Query/Command duality

show code example:
check again


HANDLERS:
- procedural code
- simplest thing that possibly work - TDD style
- only adding abstaction if pain aries, not before

Handlers can become complex?
no worries, TDD refactor step, investigating code smells
- large class -> Extract class, extract subclass
long method -> extract method, move method
push logic to the domain obhject (so load, domkain does the job, save)


Drive refactoring based on code smells.

For example complex swith statement with Strategy Pattern pattern.

So start with the smell, then drive the design

VLAIDATION SCOPES:

request VLAIDATION:
- fluentValidation

Command vlidation (domain model, db, external mode)

CROSS CUTTING CONCERNS: pipeline behaviours!!!

QUESTION: wher we need UoW?
check the a architecture is slices slidesheet

---
Further notes:
Clean Architecture favours a layered approach, where each layer is a technical concern.
VSA favours a feature-based approach, where each feature is a business concern.

Show the direction of dependencies in images
Layers for both ca and VS
- pres
- app
- domain
- infra

a slice represents a self-contained unit of functonaltiy
contains all the logic to implement a feature
- also helps to wrap the feature under feature flag

Benefits:
- improved cohesion
- reduced complexity
- focus on business logic
- high coupling inside the slice, low coupling with other features
- more screaming Architecture - easier nagivation and maintenance  

3 things in an api
- presentation logic - json, xlm, conversiin
- business logic - business rules
- persystence logic

todo: add image - also for CS project 

VSA:
You only need a new project when you need a new assembly.

Everything else should be folder structures and namespaces.

If the deployment sturcutre requires, or multiple applications would use,  you can pull out things to separate assemblies.

Use the abstractions you need but not one more. You need an abstraction? Do it

Optimize on the fly, instead of being upfront and descriptive what to use.


TODO:
- every single slice needs an integration test?!
- or we mock out DB, and do contract testing.

Either:
- Integraion tests
- plus domain

Or:
- sociable test with mocked stuff
- integration test

integratio ntests are good if we can use them to drive the design. Lot of external calls, etc, dont allow e that


MIGRATING FROM CLEAN/N-TIER
- defactor if I dont understanding, indline indline
---check the nature
-entire team should agree upon, and should have ReadToEndAsync
-process with an intended completion, or experiment and roll it back
-architecutre should have consistency
-make sure the migration compltes, or roll back

AVOID SHARED DOMAIN?
- nah, it is fine

How about extracting DB logic such?

Dont create generic sutff like manager, repo expects

Make specifif objects like XQuery, or YApprover (instead of YService.Approve())

vids:
- jim: https://www.youtube.com/watch?v=oAoaMlS1PWo
- mil: https://www.youtube.com/watch?v=msjnfdeDCmo
- cop: https://www.youtube.com/watch?v=L2Wnq0ChAIA


---

COpin:

VSA:
CA organizes code into layers
- why CA is good? Stability, everything depends on domain, so no UI changes etc should ha ve impa ct on it
- when you need a simple change, you need to change in a lot of places/projects
- physical layers (show 4 projects)
- in order to understand functionality, you need to have 10 different files to open and jump back and fort

Show CA an example: https://www.youtube.com/watch?v=L2Wnq0ChAIA
- find template projects and show the projects structure

Dont organize code by technical concerns? Because coupling

But how about cohesion? Low coupling nad high cohesion

cohesion: degree t owhich the elemnets inide a module belong together
- grouped related to operation on data
- grouped related to operations of a task



Coupling: degree of interpdenednenceb between software  modules
- show big ball of mud diagram


Logical boundaries:
feature | feature | feautre
MOOOOOODEEEEEEEEEEEEEEELELLLL
        (Database)

CQRS: 
- separation of concerns?
- eliminates the need of serivces having massive lines of codes. It streamslines the communication between developers and makes the code more intuitive.
- modelling actions in our system in terms of commands, which are things that mutate state, and queries that read state
- commands: mutate state
- add image for commands-queires
- does it solve coupling?
- you dont need, but it makes the separation clearer


TODO: refine this

SLices does not mean sharing isn't allowed. It's just it is not the default choice.

Whereas in layered approach, sharing means default choice. 

Defer sharing decision, not eliminate it.

Code sharing? 
- extension methods
- refactoring to functions/classes as logic
- domain model

Coupling here and there is not the end of the world.

Readable, testable, team-driven clean code is more important.

VSA summary:
- functional cohesion
- organize by feature
- decidesion by feature

we can still have coupling with VSA, but better cohesion.

TradeOffs vof VSA: (TODO: find more flaws)
- pragmatics over consistency
- requires constant evaluation

---
Testing .NET API
Why is it good?
Even if ou have clean architecutr,e dont change it because I said
 you can do the same, high level tests
 that's the beauty. I can easiy refactor this code using CleanArchitecture, and tests remain,
  only there will be some more dependencies for the text context

Solitary and socialble tests
Sometimes even real database, for smaller systems


---
# Coding example TODOS:

- show in the code that everyhing in one file would be in different layers
- warehousing, sales, catalog


#<span class="red-bg">Why refactoring is crucial in TDD?</span>

---

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({  
        highlightLanguage: 'cs',
         highlightStyle: 'monokai', highlightLines: true});
    </script>
  </body>
</html>
