<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./assets/style.css">
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  </head>
  <body>
    <textarea id="source">

class: center, middle

# Modern Software Development with TDD
# Day 2

---

# Day 2 Schedule

| Time          | Event                                      |
|---------------|--------------------------------------------|
| 9:00 - 10:20  | - Pragmatic Architecture                  |
| 10:30 - 12:00 | - Building .NET API with TDD             |
| 13:00 - 14:20 | - Integration testing + CQRS              |
| 14:30 - 15:50 | - Testing legacy code        |
| 16:00 - 17:30 | - Refactoring legacy   code          |

---

class: center, middle

# The Pragmatic Architecture

---
# The goal of software architecture

Easy to understand

Easy to test

Easy to change

Easy to maintain

---
# What happens with no architecture?

<div style="text-align: center;">
  <img src="./assets/no-arch.png" alt="Example Image" style="width:350px;">
</div>

---
# What happens with no architecture?

<div style="text-align: center;">
  <img src="./assets/spaghetti.jpg" alt="Example Image" style="width:500px;">
</div>

---
# What happens with no architecture?

<div style="text-align: center;">
  <img src="./assets/no-arch-structure.png" alt="Example Image" style="width:400px;">
</div>
---

# No architecture

✅Pros:
- Little to no abstraction
- Quick prototypes

❌Cons:
- Difficult to test
- Difficult to maintain
- Difficult for bigger teams
- Technology change impacts the whole system
---
# Traditional N-tier Layered Architecture


<div style="text-align: center;">
  <img src="./assets/n-tier.png" alt="Example Image" style="width:350px;">
</div>
---
# Traditional N-tier Layered Architecture


<div style="text-align: center;">
  <img src="./assets/n-tier-arch.png" alt="Example Image" style="width:400px;">
</div>

---
# DDD N-tier Layered Architecture

<div style="text-align: center;">
  <img src="./assets/ddd-n-tier.png" alt="Example Image" style="width:350px;">
</div>


---
#  N-tier Layered Architecture

✅Pros:
- Better Separation of Concerns
- Improved testability

❌Cons:
- Increased development time
- Difficult to maintain over time
- Not ideal for multiple teams

---
#  Clean Architectures

Onion Architecture

<div style="text-align: center;">
  <img src="./assets/clean-arch1.png" alt="Example Image" style="width:350px;">
</div>

---
#  Clean Architectures

Clean Architecture by Uncle Bob

<div style="text-align: center;">
  <img src="./assets/clean-arch2.jpg" alt="Example Image" style="width:450px;">
</div>

---
#  Clean Architectures

Hexagonal Architecture

<div style="text-align: center;">
  <img src="./assets/clean-arch3.png" alt="Example Image" style="width:450px;">
</div>
---

# Clean Architectures

✅Pros:
- Independent of frameworks
- Independent of UI, DB and any external dependencies
- Testable

❌Cons:
- Too opinionated - too many rules
- Organized by technical concerns
- Changes involves many layers - slower development time
- High entry curve for new developers

???
- high entry curve for developers
    - to understand functionality, you need to have many files open and jump back and forth
---
# ❌ Too many rules

Tells you how to write software without knowing the domain.

<div style="text-align: center;">
  <img src="./assets/best-practice-worst.png" alt="Example Image" style="width:450px;">
</div>
---
# ❌ Organized by technical concerns

<div style="text-align: center;">
  <img src="./assets/tech-layers-1.png" alt="Example Image" style="width:780px;">
</div>

---
# ❌ Organized by technical concerns

<div style="text-align: center;">
  <img src="./assets/tech-layers-2.png" alt="Example Image" style="width:780px;">
</div>

---
# ❌ Organized by technical concerns

<div style="text-align: center;">
  <img src="./assets/tech-layers-3.png" alt="Example Image" style="width:780px;">
</div>


---
# ❌ Organized by technical concerns

<div style="text-align: center;">
  <img src="./assets/tech-layers-4.png" alt="Example Image" style="width:780px;">
</div>


---
# ❌ Organized by technical concerns

<div style="text-align: center;">
  <img src="./assets/tech-layers-5.png" alt="Example Image" style="width:780px;">
</div>


---
# ❌ Organized by technical concerns

<div style="text-align: center;">
  <img src="./assets/tech-layers-6.png" alt="Example Image" style="width:780px;">
</div>

---
# ❌ Organized by technical concerns

<div style="text-align: center;">
  <img src="./assets/tech-layers-7.png" alt="Example Image" style="width:780px;">
</div>

---
# Low coupling, high cohesion

Coupling: degree of interdependency between software modules

Cohesion: degree to which the elemnets inside a module belong together

---
class: center, middle

# Does Clean Architecture solve this?

---
# ❌ Low coupling?

Spider web of calls
<div style="text-align: center;">
  <img src="./assets/clean-arch-cross-call.png" alt="Example Image" style="width:580px;">
</div>

---
#❌ High cohesion?

Many areas of change

Feature componetns are scattered

Too many tabs open

---
class: middle, center

# Is there a better way???

---
class: middle, center

# <span class="green-bg">Vertical Slice Architecture</span>

---

# Layers of Clean Architecture
<div style="text-align: center;">
  <img src="./assets/vsa-ca-layered.png" alt="Example Image" style="width:700px;">
</div>

---
# Remove technical layers
<div style="text-align: center;">
  <img src="./assets/vsa-unlayered.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-1.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-2.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-3.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-4.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-5.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-6.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-7.png" alt="Example Image" style="width:700px;">
</div>

---

# Organize by feature
<div style="text-align: center;">
  <img src="./assets/vsa-sliced-8.png" alt="Example Image" style="width:700px;">
</div>

---


# Use only what you need
<div style="text-align: center;">
  <img src="./assets/vsa-mixed.png" alt="Example Image" style="width:700px;">
</div>

???
It gives us the freedom to use what we want

Architecture does not tell us what to do.

Domain drives the design.
---
# Logical boundaries

Segregated by logical boundaries

Sharing still happens!

<div style="text-align: center;">
  <img src="./assets/vsa-shared-model.png" alt="Example Image" style="width:700px;">
</div>

---

# How to organize projects?

One assembly - one project

Multiple if needed for scaling

???

If the deployment sturcutre requires, or multiple applications would use, you can pull out things to separate assemblies.

---
# How to organize code

Move code to a single physical place

<div style="text-align: center;">
  <img src="./assets/vsa-move-services.png" alt="Example Image" style="width:700px;">
</div>
---
# How to organize all features

📁 Features

    |__ 📁CarPicker
       |__ 🗎 ReserveCar.cs
       |__ 🗎 UnreserveCar.cs
       |__ 🗎 HoldCar.cs
       |__ 🗎 ...
    |__ 📁UserManager

    |__ 📁PaymentProcessor

    |__ 📁InvoiceGenerator

    |__ 📁SupportCenter

    |__ ...

---

# How to organize single feature

One class - One file - One folder

<div style="text-align: center;">
  <img src="./assets/vsa-net-collapsed.png" alt="Example Image" style="width:500px;">
</div>

---
# Actions handling

<span class="red-bg">Don't use exceptions for control flow.</span>

<span class="green-bg">Exceptions are only for exceptional situations.</span>

2 kinds of errors:
- you know how to handle
  - use result paradigm
- you don't know how to handle
  - use exceptions
  - catch and handle at the lowest level

---
# Result paradigm

```
public class Result<T>
  {
      private Result(bool isSuccess, T value, Error error)
      {
          ...
      }
  
      public bool IsSuccess { get; }
  
      public bool IsFailure => !IsSuccess;
  
      public T Value { get; }
  
      public Error Error { get; }
  
      public static Result<T> Success(T value) 
        => new(true, value, Error.None);
  
      public static Result<T> Failure(Error error) 
        => new(false, default, error);
  }
```

---
class: center, middle

# <span class="orange-bg">Why all of this so powerfull?</span>

---
# Pragmatism

- ✅ Minimal and lean solution
- ✅ Guidelines over rigid rules
- ✅ Freedom of choice

<div style="text-align: center;">
  <img src="./assets/vsa-query-3-forms.png" alt="Example Image" style="width:600px;">
</div>

???
It supports to mindset of a pragmatic engineer menaing ...
That is how we want to keep our solutions lean, simple and minimal. 
Software practices are guidelines not rigid rules.

it does not mean that my team members can do whatever they want.
but they can use whatever they need

the best practice is is to use our critical thinking

---

# High cohesion

✅ Everything in one place

✅ Screaming architecture

✅ App is organized by features, not by technical concerns

✅ Focused on business logic

---

# How about coupling?

✅ High coupling inside the slice

✅ Low coupling with other features

✅ Reduced complexity -> more confidence


???
high coupling inside slcie is readonable as the things which sh ould change together should live together

---
# Code sharing

Layered approach: sharing is default

Slice approach: sharing is optional

<span class="orange-bg">Defer decision, not eliminate it.</span>

How to share:
- extension methods
- refactoring to functions/classes
- rich domain model

???
SLices does not mean sharing isn't allowed. It's just it is not the default choice.

Whereas in layered approach, sharing means default choice. 


---
class: center, middle

# <span class="red-bg"> That's it? </span>

---
class: center, middle

# <span class="green-bg">The Ultimate TDD Strategy </span>

---

# Two kind of unit tests

<div style="text-align: center;">
  <img src="./assets/vsa-solitary-vs-sociable.png" alt="Example Image" style="width:600px;">
</div>


---
class: center, middle

# <span class="red-bg">Don't couple your tests to code structure</span>

# <span class="green-bg">Couple them to the behaviours of the public APIs</span>

???
dont; coumple your tests to code strucrture, they will be fragile, bla bla
---
# Sociable test on WebAPI

- Entry point: public API of WebAPI
- London mixed with Chicago
- State vs interaction verification
- Minimizing low-level tests

<div style="text-align: center;">
  <img src="./assets/vsa-sociable-web-api.png" alt="Example Image" style="width:500px;">
</div>

???
  - Exceptions: domain heavy logic or prop tests
---

# Tech-agnostic tests

<div style="text-align: center;">
  <img src="./assets/vsa-sociable-web-api.png" alt="Example Image" style="width:600px;">
</div>

---

# Tech-agnostic tests

<div style="text-align: center;">
  <img src="./assets/vsa-sociable-web-api-2.png" alt="Example Image" style="width:600px;">
</div>

---

# Tech-agnostic tests

<div style="text-align: center;">
  <img src="./assets/vsa-sociable-web-api-3.png" alt="Example Image" style="width:600px;">
</div>

---

# Tech-agnostic tests

<div style="text-align: center;">
  <img src="./assets/vsa-sociable-web-api-4.png" alt="Example Image" style="width: 600px;">
</div>

???
Even if ou have clean architecutr,e dont change it because I said
 you can do the same, high level tests
 that's the beauty. I can easiy refactor this code using CleanArchitecture, and tests remain,
  only there will be some more dependencies for the text context

---

# Acceptance Test-Driven Development (ATDD)

What the system should do from the user POV

Unit tests becomes Acceptance Tests

What to test:

- What are the observable behaviors?

- What are the side effects?

- What is the interaction with external systems?

???
TDD has a special form called Acceptance Test-Driven Development (ATDD). Acceptance Tests provide us with a user-focused take on what our system should do. They work alongside technical tests to check how the system behaves from an outside perspective, in real-life scenarious. ATDD is an approach that focuses on building software around its intended purpose and outcomes rather than specific technologies or implementation details. This “outside-in


---
# Summary

Pragmatic mindset

Use what you need, throw away what you don't.

Use the abstractions you only need but not one more. 

Optimize on the fly, instead of being upfront and descriptive what to use.

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({  
        highlightLanguage: 'cs',
         highlightStyle: 'monokai', highlightLines: true,
         ratio: '16:9'});
    </script>
  </body>
</html>
